'use strict';

function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import React, { Component } from 'react';
import { AppState, View } from 'react-native';
const DEFAULT_DELAY = 1000;
class TimeoutHandler {
  constructor() {
    _defineProperty(this, "handlerRef", {
      id: -1
    });
  }
  get handler() {
    return this.handlerRef.id;
  }
  set handler(n) {
    this.handlerRef.id = n;
  }
  clear() {
    clearTimeout(this.handlerRef.id);
  }
}
function setIntervalWithTimeout(callback, intervalMs, handleWrapper = new TimeoutHandler()) {
  let cleared = false;
  const timeout = () => {
    handleWrapper.handler = setTimeout(() => {
      callback(() => {
        cleared = true;
        handleWrapper.clear();
      });
      if (!cleared) {
        timeout();
      }
    }, intervalMs);
  };
  timeout();
  return handleWrapper;
}

/**
 * Detects when this is in the viewport and visible.
 *
 * Will not fire visibility changes for zero width/height components.
 */
export default class ViewPortDetector extends Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "lastValue", null);
    _defineProperty(this, "interval", null);
    _defineProperty(this, "view", null);
    _defineProperty(this, "lastAppStateActive", false);
    _defineProperty(this, "appStateSubscription", null);
    _defineProperty(this, "hasValidTimeout", (disabled, delay) => {
      let disabledValue = disabled ?? false;
      let delayValue = delay ?? DEFAULT_DELAY;
      return AppState.currentState === 'active' && !disabledValue && delayValue > 0;
    });
    _defineProperty(this, "handleAppStateChange", nextAppState => {
      let nextAppStateActive = nextAppState === 'active';
      if (this.lastAppStateActive !== nextAppStateActive) {
        this.checkVisibility();
      }
      this.lastAppStateActive = nextAppStateActive;
      if (!this.hasValidTimeout(this.props.disabled, this.props.delay)) {
        this.stopWatching();
      } else {
        this.startWatching();
      }
    });
    _defineProperty(this, "startWatching", () => {
      if (this.interval) {
        return;
      }
      this.interval = setIntervalWithTimeout(this.checkVisibility, this.props.delay || DEFAULT_DELAY);
    });
    _defineProperty(this, "stopWatching", () => {
      var _this$interval;
      (_this$interval = this.interval) === null || _this$interval === void 0 || _this$interval.clear();
      this.interval = null;
    });
    _defineProperty(this, "checkVisibility", () => {
      if (!this.view) {
        return;
      }
      if (AppState.currentState !== 'active') {
        this.updateVisibility(false);
        return;
      }
      this.view.measure((_x, _y, width, height, _pageX, _pageY) => {
        this.checkInViewPort(width, height);
      });
    });
    _defineProperty(this, "checkInViewPort", (width, height) => {
      let isVisible;
      // Not visible if any of these are missing.
      if (!width || !height) {
        isVisible = false;
      } else {
        isVisible = true;
      }
      this.updateVisibility(isVisible);
    });
    _defineProperty(this, "updateVisibility", isVisible => {
      if (this.lastValue !== isVisible) {
        var _this$props$onChange, _this$props;
        this.lastValue = isVisible;
        (_this$props$onChange = (_this$props = this.props).onChange) === null || _this$props$onChange === void 0 || _this$props$onChange.call(_this$props, isVisible);
      }
    });
    this.state = {
      rectTop: 0,
      rectBottom: 0
    };
  }
  componentDidMount() {
    this.lastAppStateActive = AppState.currentState === 'active';
    this.appStateSubscription = AppState.addEventListener('change', this.handleAppStateChange);
    if (this.hasValidTimeout(this.props.disabled, this.props.delay)) {
      this.startWatching();
    }
  }
  componentWillUnmount() {
    var _this$appStateSubscri;
    (_this$appStateSubscri = this.appStateSubscription) === null || _this$appStateSubscri === void 0 || _this$appStateSubscri.remove();
    this.appStateSubscription = null;
    this.stopWatching();
  }
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (!this.hasValidTimeout(nextProps.disabled, nextProps.delay)) {
      this.stopWatching();
    } else {
      if (this.props.propKey !== nextProps.propKey) {
        this.lastValue = null;
      }
      this.startWatching();
    }
  }
  render() {
    return /*#__PURE__*/React.createElement(View, _extends({
      collapsable: false,
      ref: component => {
        this.view = component;
      }
    }, this.props), this.props.children);
  }
}
//# sourceMappingURL=ViewPortDetector.js.map