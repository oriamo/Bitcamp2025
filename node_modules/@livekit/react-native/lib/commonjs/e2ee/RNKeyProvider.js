"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _livekitClient = require("livekit-client");
var _reactNativeWebrtc = require("@livekit/react-native-webrtc");
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const defaultRatchetSalt = 'LKFrameEncryptionKey';
const defaultMagicBytes = 'LK-ROCKS';
const defaultRatchetWindowSize = 16;
const defaultFailureTolerance = -1;
const defaultKeyRingSize = 16;
const defaultDiscardFrameWhenCryptorNotReady = false;

/**
 * Options for construction an RNKeyProvider
 */

/**
 * @experimental
 */
class RNKeyProvider extends _livekitClient.BaseKeyProvider {
  constructor(options) {
    const opts = {
      sharedKey: options.sharedKey ?? true,
      ratchetSalt: options.ratchetSalt ?? defaultRatchetSalt,
      ratchetWindowSize: options.ratchetWindowSize ?? defaultRatchetWindowSize,
      failureTolerance: options.failureTolerance ?? defaultFailureTolerance,
      keyRingSize: options.keyringSize ?? defaultKeyRingSize,
      keyringSize: options.keyringSize ?? defaultKeyRingSize,
      discardFrameWhenCryptorNotReady: defaultDiscardFrameWhenCryptorNotReady
    };
    let magicBytes = options.uncryptedMagicBytes ?? defaultMagicBytes;
    if (typeof magicBytes === 'string') {
      magicBytes = new TextEncoder().encode(magicBytes);
    }
    opts.uncryptedMagicBytes = magicBytes;
    super(opts);
    _defineProperty(this, "latestSetIndex", new Map());
    _defineProperty(this, "nativeKeyProvider", void 0);
    this.nativeKeyProvider = _reactNativeWebrtc.RTCFrameCryptorFactory.createDefaultKeyProvider(opts);
  }
  getLatestKeyIndex(participantId) {
    return this.latestSetIndex.get(participantId) ?? 0;
  }

  /**
   * Accepts a passphrase that's used to create the crypto keys.
   * @param key
   */
  async setSharedKey(key, keyIndex) {
    return this.nativeKeyProvider.setSharedKey(key, keyIndex);
  }
  async ratchetSharedKey(keyIndex) {
    this.nativeKeyProvider.ratchetSharedKey(keyIndex);
  }

  /**
   * Accepts a passphrase that's used to create the crypto keys for a participant's stream.
   * @param key
   */
  async setKey(participantId, key, keyIndex) {
    if (this.getOptions().sharedKey) {
      return this.setSharedKey(key, keyIndex);
    }
    this.latestSetIndex.set(participantId, keyIndex ?? 0);
    return this.nativeKeyProvider.setKey(participantId, key, keyIndex);
  }
  async ratchetKey(participantIdentity, keyIndex) {
    if (!this.getOptions().sharedKey && participantIdentity) {
      this.nativeKeyProvider.ratchetKey(participantIdentity, keyIndex);
    } else {
      this.ratchetSharedKey(keyIndex);
    }
  }
  async setSifTrailer(trailer) {
    return this.nativeKeyProvider.setSifTrailer(trailer);
  }

  /**
   * @internal
   */
  get rtcKeyProvider() {
    return this.nativeKeyProvider;
  }
  dispose() {
    this.nativeKeyProvider.dispose();
  }
}

// /**
//  * Define the `onxxx` event handlers.
//  */
// const proto = RNExternalE2EEKeyProvider.prototype;

// defineEventAttribute(proto, KeyProviderEvent.SetKey);
// defineEventAttribute(proto, KeyProviderEvent.RatchetRequest);
// defineEventAttribute(proto, KeyProviderEvent.KeyRatcheted);
exports.default = RNKeyProvider;
//# sourceMappingURL=RNKeyProvider.js.map