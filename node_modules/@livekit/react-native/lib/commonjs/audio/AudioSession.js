"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AndroidAudioTypePresets = void 0;
exports.getDefaultAppleAudioConfigurationForMode = getDefaultAppleAudioConfigurationForMode;
var _reactNative = require("react-native");
var _LKNativeModule = _interopRequireDefault(require("../LKNativeModule"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Configuration for the underlying AudioSession.
 *
 * ----
 * Android specific options:
 *
 * * preferredOutputList - The preferred order in which to automatically select an audio output.
 *   This is ignored when an output is manually selected with {@link AudioSession.selectAudioOutput}.
 *
 *   By default, the order is set to:
 *   1. `"bluetooth"
 *   2. `"headset"``
 *   3. `"speaker"`
 *   4. `"earpiece"`
 *
 * * audioTypeOptions - An {@link AndroidAudioTypeOptions} object which provides the
 *   audio options to use on Android.
 *
 *   See {@link AndroidAudioTypePresets} for pre-configured values.
 *
 * ----
 * iOS
 *
 * * defaultOutput - The default preferred output to use when a wired headset or bluetooth output is unavailable.
 *
 *   By default, this is set to `"speaker"`
 */

const AndroidAudioTypePresets = exports.AndroidAudioTypePresets = {
  communication: {
    manageAudioFocus: true,
    audioMode: 'inCommunication',
    audioFocusMode: 'gain',
    audioStreamType: 'voiceCall',
    audioAttributesUsageType: 'voiceCommunication',
    audioAttributesContentType: 'speech'
  },
  media: {
    manageAudioFocus: true,
    audioMode: 'normal',
    audioFocusMode: 'gain',
    audioStreamType: 'music',
    audioAttributesUsageType: 'media',
    audioAttributesContentType: 'unknown'
  }
};
function getDefaultAppleAudioConfigurationForMode(mode, preferSpeakerOutput = true) {
  if (mode === 'remoteOnly') {
    return {
      audioCategory: 'playback',
      audioCategoryOptions: ['mixWithOthers'],
      audioMode: 'spokenAudio'
    };
  } else if (mode === 'localAndRemote' || mode === 'localOnly') {
    return {
      audioCategory: 'playAndRecord',
      audioCategoryOptions: ['allowBluetooth', 'mixWithOthers'],
      audioMode: preferSpeakerOutput ? 'videoChat' : 'voiceChat'
    };
  }
  return {
    audioCategory: 'soloAmbient',
    audioCategoryOptions: [],
    audioMode: 'default'
  };
}
class AudioSession {}
exports.default = AudioSession;
/**
 * Applies the provided audio configuration to the underlying AudioSession.
 *
 * Must be called prior to connecting to a Room for the configuration to apply correctly.
 *
 * See also useIOSAudioManagement for automatic configuration of iOS audio options.
 */
_defineProperty(AudioSession, "configureAudio", async config => {
  await _LKNativeModule.default.configureAudio(config);
});
/**
 * Starts an AudioSession.
 */
_defineProperty(AudioSession, "startAudioSession", async () => {
  await _LKNativeModule.default.startAudioSession();
});
/**
 * Stops the existing AudioSession.
 */
_defineProperty(AudioSession, "stopAudioSession", async () => {
  await _LKNativeModule.default.stopAudioSession();
});
/**
 * Gets the available audio outputs for use with {@link selectAudioOutput}.
 *
 * {@link startAudioSession} must be called prior to using this method.
 *
 * For Android, will return if available:
 * * "speaker"
 * * "earpiece"
 * * "headset"
 * * "bluetooth"
 *
 * ----
 *
 * For iOS, due to OS limitations, the only available types are:
 * * "default" - Use default iOS audio routing
 * * "force_speaker" - Force audio output through speaker
 *
 * See also {@link showAudioRoutePicker} to display a route picker that
 * can choose between other audio devices (i.e. headset/bluetooth/airplay),
 * or use a library like `react-native-avroutepicker` for a native platform
 * control.
 *
 * @returns the available audio output types
 */
_defineProperty(AudioSession, "getAudioOutputs", async () => {
  if (_reactNative.Platform.OS === 'ios') {
    return ['default', 'force_speaker'];
  } else if (_reactNative.Platform.OS === 'android') {
    return await _LKNativeModule.default.getAudioOutputs();
  } else {
    return [];
  }
});
/**
 * Select the provided audio output if available.
 *
 * {@link startAudioSession} must be called prior to using this method.
 *
 * @param deviceId A deviceId retrieved from {@link getAudioOutputs}
 */
_defineProperty(AudioSession, "selectAudioOutput", async deviceId => {
  await _LKNativeModule.default.selectAudioOutput(deviceId);
});
/**
 * iOS only, requires iOS 11+.
 *
 * Displays an AVRoutePickerView for the user to choose their audio output.
 */
_defineProperty(AudioSession, "showAudioRoutePicker", async () => {
  if (_reactNative.Platform.OS === 'ios') {
    await _LKNativeModule.default.showAudioRoutePicker();
  }
});
/**
 * Directly change the AVAudioSession category/mode.
 *
 * @param config The configuration to use. Null values will be omitted and the
 * existing values will be unchanged.
 */
_defineProperty(AudioSession, "setAppleAudioConfiguration", async config => {
  if (_reactNative.Platform.OS === 'ios') {
    await _LKNativeModule.default.setAppleAudioConfiguration(config);
  }
});
//# sourceMappingURL=AudioSession.js.map