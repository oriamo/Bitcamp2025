"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useIOSAudioManagement = useIOSAudioManagement;
var _react = require("react");
var _reactNative = require("react-native");
var _livekitClient = require("livekit-client");
var _AudioSession = _interopRequireWildcard(require("./AudioSession"));
var _ = require("..");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Handles setting the appropriate AVAudioSession options automatically
 * depending on the audio track states of the Room.
 *
 * @param room
 * @param preferSpeakerOutput
 * @param onConfigureNativeAudio A custom method for determining options used.
 */
function useIOSAudioManagement(room, preferSpeakerOutput = true, onConfigureNativeAudio) {
  const [localTrackCount, setLocalTrackCount] = (0, _react.useState)(0);
  const [remoteTrackCount, setRemoteTrackCount] = (0, _react.useState)(0);
  const trackState = (0, _react.useMemo)(() => computeAudioTrackState(localTrackCount, remoteTrackCount), [localTrackCount, remoteTrackCount]);
  (0, _react.useEffect)(() => {
    let recalculateTrackCounts = () => {
      setLocalTrackCount(getLocalAudioTrackCount(room));
      setRemoteTrackCount(getRemoteAudioTrackCount(room));
    };
    recalculateTrackCounts();
    room.on(_livekitClient.RoomEvent.Connected, recalculateTrackCounts);
    return () => {
      room.off(_livekitClient.RoomEvent.Connected, recalculateTrackCounts);
    };
  }, [room]);
  (0, _react.useEffect)(() => {
    if (_reactNative.Platform.OS !== 'ios') {
      return () => {};
    }
    let onLocalPublished = publication => {
      if (publication.kind === 'audio') {
        setLocalTrackCount(localTrackCount + 1);
      }
    };
    let onLocalUnpublished = publication => {
      if (publication.kind === 'audio') {
        if (localTrackCount - 1 < 0) {
          _.log.warn('mismatched local audio track count! attempted to reduce track count below zero.');
        }
        setLocalTrackCount(Math.max(localTrackCount - 1, 0));
      }
    };
    let onRemotePublished = publication => {
      if (publication.kind === 'audio') {
        setRemoteTrackCount(remoteTrackCount + 1);
      }
    };
    let onRemoteUnpublished = publication => {
      if (publication.kind === 'audio') {
        if (remoteTrackCount - 1 < 0) {
          _.log.warn('mismatched remote audio track count! attempted to reduce track count below zero.');
        }
        setRemoteTrackCount(Math.max(remoteTrackCount - 1, 0));
      }
    };
    room.on(_livekitClient.RoomEvent.LocalTrackPublished, onLocalPublished).on(_livekitClient.RoomEvent.LocalTrackUnpublished, onLocalUnpublished).on(_livekitClient.RoomEvent.TrackPublished, onRemotePublished).on(_livekitClient.RoomEvent.TrackUnpublished, onRemoteUnpublished);
    return () => {
      room.off(_livekitClient.RoomEvent.LocalTrackPublished, onLocalPublished).off(_livekitClient.RoomEvent.LocalTrackUnpublished, onLocalUnpublished).off(_livekitClient.RoomEvent.TrackPublished, onRemotePublished).off(_livekitClient.RoomEvent.TrackUnpublished, onRemoteUnpublished);
    };
  }, [room, localTrackCount, remoteTrackCount]);
  (0, _react.useEffect)(() => {
    if (_reactNative.Platform.OS !== 'ios') {
      return;
    }
    let configFunc = onConfigureNativeAudio ?? _AudioSession.getDefaultAppleAudioConfigurationForMode;
    let audioConfig = configFunc(trackState, preferSpeakerOutput);
    _AudioSession.default.setAppleAudioConfiguration(audioConfig);
  }, [trackState, onConfigureNativeAudio, preferSpeakerOutput]);
}
function computeAudioTrackState(localTracks, remoteTracks) {
  if (localTracks > 0 && remoteTracks > 0) {
    return 'localAndRemote';
  } else if (localTracks > 0 && remoteTracks === 0) {
    return 'localOnly';
  } else if (localTracks === 0 && remoteTracks > 0) {
    return 'remoteOnly';
  } else {
    return 'none';
  }
}
function getLocalAudioTrackCount(room) {
  return room.localParticipant.audioTrackPublications.size;
}
function getRemoteAudioTrackCount(room) {
  var audioTracks = 0;
  room.remoteParticipants.forEach(participant => {
    audioTracks += participant.audioTrackPublications.size;
  });
  return audioTracks;
}
//# sourceMappingURL=AudioManager.js.map