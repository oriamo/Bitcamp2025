"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useParticipant = useParticipant;
var _livekitClient = require("livekit-client");
var _react = require("react");
/** @deprecated use `useRemoteParticipant` or `useLocalParticipant` instead */

/** @deprecated use `useRemoteParticipant` or `useLocalParticipant` instead */
function useParticipant(participant) {
  const [isAudioMuted, setAudioMuted] = (0, _react.useState)(false);
  const [, setVideoMuted] = (0, _react.useState)(false);
  const [connectionQuality, setConnectionQuality] = (0, _react.useState)(participant.connectionQuality);
  const [isSpeaking, setSpeaking] = (0, _react.useState)(false);
  const [metadata, setMetadata] = (0, _react.useState)();
  const [publications, setPublications] = (0, _react.useState)([]);
  const [subscribedTracks, setSubscribedTracks] = (0, _react.useState)([]);
  const [cameraPublication, setCameraPublication] = (0, _react.useState)(participant.getTrackPublication(_livekitClient.Track.Source.Camera));
  const [microphonePublication, setMicrophonePublication] = (0, _react.useState)(participant.getTrackPublication(_livekitClient.Track.Source.Microphone));
  const [screenSharePublication, setScreenSharePublication] = (0, _react.useState)(participant.getTrackPublication(_livekitClient.Track.Source.ScreenShare));
  (0, _react.useEffect)(() => {
    const onPublicationsChanged = () => {
      setPublications(Array.from(participant.trackPublications.values()));
      setCameraPublication(participant.getTrackPublication(_livekitClient.Track.Source.Camera));
      setMicrophonePublication(participant.getTrackPublication(_livekitClient.Track.Source.Microphone));
      setScreenSharePublication(participant.getTrackPublication(_livekitClient.Track.Source.ScreenShare));
      setSubscribedTracks(Array.from(participant.trackPublications.values()).filter(pub => {
        return pub.isSubscribed && pub.track !== undefined;
      }));
    };
    const onMuted = pub => {
      if (pub.kind === _livekitClient.Track.Kind.Audio) {
        setAudioMuted(true);
      } else if (pub.kind === _livekitClient.Track.Kind.Video) {
        setVideoMuted(true);
      }
    };
    const onUnmuted = pub => {
      if (pub.kind === _livekitClient.Track.Kind.Audio) {
        setAudioMuted(false);
      } else if (pub.kind === _livekitClient.Track.Kind.Video) {
        setVideoMuted(false);
      }
    };
    const onMetadataChanged = () => {
      if (participant.metadata) {
        setMetadata(participant.metadata);
      }
    };
    const onIsSpeakingChanged = () => {
      setSpeaking(participant.isSpeaking);
    };
    const onConnectionQualityUpdate = () => {
      setConnectionQuality(participant.connectionQuality);
    };

    // register listeners
    participant.on(_livekitClient.ParticipantEvent.TrackMuted, onMuted).on(_livekitClient.ParticipantEvent.TrackUnmuted, onUnmuted).on(_livekitClient.ParticipantEvent.ParticipantMetadataChanged, onMetadataChanged).on(_livekitClient.ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged).on(_livekitClient.ParticipantEvent.TrackPublished, onPublicationsChanged).on(_livekitClient.ParticipantEvent.TrackUnpublished, onPublicationsChanged).on(_livekitClient.ParticipantEvent.TrackSubscribed, onPublicationsChanged).on(_livekitClient.ParticipantEvent.TrackUnsubscribed, onPublicationsChanged).on(_livekitClient.ParticipantEvent.LocalTrackPublished, onPublicationsChanged).on(_livekitClient.ParticipantEvent.LocalTrackUnpublished, onPublicationsChanged).on(_livekitClient.ParticipantEvent.ConnectionQualityChanged, onConnectionQualityUpdate);

    // set initial state
    onMetadataChanged();
    onIsSpeakingChanged();
    onPublicationsChanged();
    return () => {
      // cleanup
      participant.off(_livekitClient.ParticipantEvent.TrackMuted, onMuted).off(_livekitClient.ParticipantEvent.TrackUnmuted, onUnmuted).off(_livekitClient.ParticipantEvent.ParticipantMetadataChanged, onMetadataChanged).off(_livekitClient.ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged).off(_livekitClient.ParticipantEvent.TrackPublished, onPublicationsChanged).off(_livekitClient.ParticipantEvent.TrackUnpublished, onPublicationsChanged).off(_livekitClient.ParticipantEvent.TrackSubscribed, onPublicationsChanged).off(_livekitClient.ParticipantEvent.TrackUnsubscribed, onPublicationsChanged).off(_livekitClient.ParticipantEvent.LocalTrackPublished, onPublicationsChanged).off(_livekitClient.ParticipantEvent.LocalTrackUnpublished, onPublicationsChanged).off(_livekitClient.ParticipantEvent.ConnectionQualityChanged, onConnectionQualityUpdate);
    };
  }, [participant]);
  let muted;
  participant.audioTrackPublications.forEach(pub => {
    muted = pub.isMuted;
  });
  if (muted === undefined) {
    muted = true;
  }
  if (isAudioMuted !== muted) {
    setAudioMuted(muted);
  }
  return {
    isLocal: participant instanceof _livekitClient.LocalParticipant,
    isSpeaking,
    connectionQuality,
    publications,
    subscribedTracks,
    cameraPublication,
    microphonePublication,
    screenSharePublication,
    metadata
  };
}
//# sourceMappingURL=useParticipant.js.map